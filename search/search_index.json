{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Neutron"},{"location":"/index.html#neutron","text":"Neutron is a purely functional Apache Pulsar client for Scala, build on top of fs2 and the Java Pulsar client.\nIt is published for Scala 2.12/13 and can be included in your project.\nsbt libraryDependencies ++= Seq(\n  \"com.chatroulette\" %% \"neutron-core\" % \"0.0.1\",\n  \"com.chatroulette\" % \"$neutron-circe$\" % \"0.0.1\",\n  \"com.chatroulette\" %% \"neutron-function\" % \"0.0.1\"\n) Maven <dependency>\n  <groupId>com.chatroulette</groupId>\n  <artifactId>neutron-core_2.12</artifactId>\n  <version>0.0.1</version>\n</dependency>\n<dependency>\n  <groupId>com.chatroulette</groupId>\n  <artifactId>$neutron-circe$</artifactId>\n  <version>0.0.1</version>\n</dependency>\n<dependency>\n  <groupId>com.chatroulette</groupId>\n  <artifactId>neutron-function_2.12</artifactId>\n  <version>0.0.1</version>\n</dependency> Gradle dependencies {\n  compile group: 'com.chatroulette', name: 'neutron-core_2.12', version: '0.0.1',\n  compile group: 'com.chatroulette', name: '$neutron-circe$', version: '0.0.1',\n  compile group: 'com.chatroulette', name: 'neutron-function_2.12', version: '0.0.1'\n}","title":"Neutron"},{"location":"/index.html#quick-start","text":"Here’s a quick consumer / producer example using Neutron. Note: both are fully asynchronous.\nimport cats.effect._\nimport fs2.Stream\nimport cr.pulsar._\nimport cr.pulsar.schema.utf8._\nimport org.apache.pulsar.client.api.SubscriptionInitialPosition\nimport scala.concurrent.duration._\n\nobject Demo extends IOApp {\n\n  // Pulsar configuration\n  val config  = Config.default\n  val topic   = Topic(config, Topic.Name(\"my-topic\"), Topic.Type.NonPersistent)\n\n  // Consumer details\n  val subs    = Subscription(Subscription.Name(\"my-sub\"), Subscription.Type.Shared)\n  val initPos = SubscriptionInitialPosition.Latest\n\n  val resources: Resource[IO, (Consumer[IO], Producer[IO, String])] =\n    for {\n      client   <- Pulsar.create[IO](config.serviceUrl)\n      consumer <- Consumer.create[IO](client, topic, subs, initPos)\n      producer <- Producer.create[IO, String](client, topic)\n    } yield (consumer, producer)\n\n  def run(args: List[String]): IO[ExitCode] =\n    Stream\n      .resource(resources)\n      .flatMap {\n        case (consumer, producer) =>\n          val consume =\n            consumer\n              .subscribe\n              .evalTap(m => IO(println(stringBytesInject.prj(m.getData))))\n              .evalMap(m => consumer.ack(m.getMessageId))\n\n          val produce =\n            Stream\n              .emit(\"test data\")\n              .covary[IO]\n              .metered(3.seconds)\n              .evalMap(producer.send_)\n\n          consume.concurrently(produce)\n      }.compile.drain.as(ExitCode.Success)\n\n}","title":"Quick start"},{"location":"/index.html#schema","text":"Neutron relies on cats.Inject[A, Array[Byte]] instances to be able to decode & encode messages from & to raw bytes instead of using the native schema solution. As functional programmers, we believe this has certain benefits. In the example above, we are using a standard “UTF-8” encoding of String => Array[Byte], brought by import cr.pulsar.schema.utf8._.\nAt Chatroulette, we use JSON-serialised data for which we define an Inject instance based on Circe codecs. Those interested in doing the same can leverage the Circe integration by adding the neutron-circe extra dependency (available since v0.0.2).\nOnce you added the dependency, you are an import away from having JSON schema based on Circe.\nimport cr.pulsar.schema.circe._\nBe aware that your datatype needs to provide instances of io.circe.Encoder and io.circe.Decoder for this instance to be available.","title":"Schema"}]}