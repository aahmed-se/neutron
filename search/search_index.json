{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Neutron"},{"location":"/index.html#neutron","text":"Neutron is a purely functional Apache Pulsar client for Scala, build on top of fs2 and the Java Pulsar client.\nIt is published for Scala 2.13. You can include it in your project by adding the following dependencies.\nsbt libraryDependencies ++= Seq(\n  \"com.chatroulette\" %% \"neutron-core\" % \"0.0.4\",\n  \"com.chatroulette\" %% \"neutron-circe\" % \"0.0.4\",\n  \"com.chatroulette\" %% \"neutron-function\" % \"0.0.4\"\n) Maven <dependencies>\n  <dependency>\n    <groupId>com.chatroulette</groupId>\n    <artifactId>neutron-core_2.13</artifactId>\n    <version>0.0.4</version>\n  </dependency>\n  <dependency>\n    <groupId>com.chatroulette</groupId>\n    <artifactId>neutron-circe_2.13</artifactId>\n    <version>0.0.4</version>\n  </dependency>\n  <dependency>\n    <groupId>com.chatroulette</groupId>\n    <artifactId>neutron-function_2.13</artifactId>\n    <version>0.0.4</version>\n  </dependency>\n</dependencies> Gradle dependencies {\n  implementation \"com.chatroulette:neutron-core_2.13:0.0.4\"\n  implementation \"com.chatroulette:neutron-circe_2.13:0.0.4\"\n  implementation \"com.chatroulette:neutron-function_2.13:0.0.4\"\n}","title":"Neutron"},{"location":"/index.html#quick-start","text":"Here’s a quick consumer / producer example using Neutron. Note: both are fully asynchronous.\nimport cats.effect._\nimport cats.implicits._\nimport fs2.Stream\nimport cr.pulsar._\nimport cr.pulsar.schema.utf8._\nimport scala.concurrent.duration._\n\nobject Demo extends IOApp {\n\n  val config = Config.Builder.default\n\n  val topic  =\n    Topic.Builder\n      .withName(\"my-topic\")\n      .withConfig(config)\n      .withType(Topic.Type.NonPersistent)\n      .build\n\n  val subs =\n    Subscription.Builder\n      .withName(\"my-sub\")\n      .withType(Subscription.Type.Shared)\n      .build\n\n  val resources: Resource[IO, (Consumer[IO, String], Producer[IO, String])] =\n    for {\n      pulsar   <- Pulsar.create[IO](config.url)\n      consumer <- Consumer.create[IO, String](pulsar, topic, subs)\n      producer <- Producer.create[IO, String](pulsar, topic)\n    } yield (consumer, producer)\n\n  def run(args: List[String]): IO[ExitCode] =\n    Stream\n      .resource(resources)\n      .flatMap {\n        case (consumer, producer) =>\n          val consume =\n            consumer\n              .subscribe\n              .evalMap(m => IO(println(m.payload)) >> consumer.ack(m.id))\n\n          val produce =\n            Stream\n              .emit(\"test data\")\n              .covary[IO]\n              .metered(3.seconds)\n              .evalMap(producer.send_(_))\n\n          consume.concurrently(produce)\n      }.compile.drain.as(ExitCode.Success)\n\n}","title":"Quick start"},{"location":"/index.html#schema","text":"Neutron relies on cats.Inject[A, Array[Byte]] instances to be able to decode & encode messages from & to raw bytes instead of using the native schema solution. As functional programmers, we believe this has certain benefits. In the example above, we are using a standard “UTF-8” encoding String <=> Array[Byte], brought by import cr.pulsar.schema.utf8._.\nAt Chatroulette, we use JSON-serialised data for which we define an Inject instance based on Circe codecs. Those interested in doing the same can leverage the Circe integration by adding the neutron-circe extra dependency (available since v0.0.2).\nOnce you added the dependency, you are an import away from having JSON schema based on Circe.\nimport cr.pulsar.schema.circe._\nBe aware that your datatype needs to provide instances of io.circe.Encoder and io.circe.Decoder for this instance to become available.","title":"Schema"}]}