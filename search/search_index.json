{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Neutron"},{"location":"/index.html#neutron","text":"Neutron is a purely functional Apache Pulsar client for Scala, build on top of fs2 and the Java Pulsar client.\nIt is published for Scala 2.12/13 and can be included in your project.\nsbt libraryDependencies ++= Seq(\n  \"com.chatroulette\" %% \"neutron-core\" % \"0.0.1\",\n  \"com.chatroulette\" %% \"neutron-function\" % \"0.0.1\"\n) Maven <dependency>\n  <groupId>com.chatroulette</groupId>\n  <artifactId>neutron-core_2.12</artifactId>\n  <version>0.0.1</version>\n</dependency>\n<dependency>\n  <groupId>com.chatroulette</groupId>\n  <artifactId>neutron-function_2.12</artifactId>\n  <version>0.0.1</version>\n</dependency> Gradle dependencies {\n  compile group: 'com.chatroulette', name: 'neutron-core_2.12', version: '0.0.1',\n  compile group: 'com.chatroulette', name: 'neutron-function_2.12', version: '0.0.1'\n}","title":"Neutron"},{"location":"/index.html#quick-start","text":"Hereâ€™s a quick consumer / producer example using Neutron.\nimport cats.Inject\nimport cats.effect._\nimport cats.implicits._\nimport fs2.Stream\nimport cr.pulsar._\nimport org.apache.pulsar.client.api.SubscriptionInitialPosition\nimport scala.concurrent.duration._\n\nobject Demo extends IOApp {\n\n  // Pulsar configuration\n  val config  = Config.default\n  val topic   = Topic(config, Topic.Name(\"my-topic\"), Topic.Type.NonPersistent)\n\n  // Consumer details\n  val subs    = Subscription(Subscription.Name(\"my-sub\"), Subscription.Type.Shared)\n  val initPos = SubscriptionInitialPosition.Latest\n\n  // Producer details\n  val shardKey: String => Producer.MessageKey = _ => Producer.MessageKey.Default\n  val batching = Producer.Batching.Disabled\n\n  // Needed for consumers and producers to be able to decode and encode messages, respectively\n  implicit val stringBytesInject: Inject[String, Array[Byte]] =\n    new Inject[String, Array[Byte]] {\n      override val inj: String => Array[Byte] = _.getBytes(\"UTF-8\")\n      override val prj: Array[Byte] => Option[String] = new String(_, \"UTF-8\").some\n    }\n\n  val resources: Resource[IO, (Consumer[IO], Producer[IO, String])] =\n    for {\n      client <- PulsarClient.create[IO](config.serviceUrl)\n      blocker <- Blocker[IO]\n      consumer <- Consumer.create[IO](client, topic, subs, initPos)\n      producer <- Producer.create[IO, String](client, topic, shardKey, batching, blocker)\n    } yield (consumer, producer)\n\n  def run(args: List[String]): IO[ExitCode] =\n    Stream\n      .resource(resources)\n      .flatMap {\n        case (consumer, producer) =>\n          val consume =\n            consumer\n              .subscribe\n              .evalTap(m => IO(println(stringBytesInject.prj(m.getData))))\n              .evalMap(m => consumer.ack(m.getMessageId))\n\n          val produce =\n            Stream\n              .emit(\"test data\")\n              .covary[IO]\n              .metered(3.seconds)\n              .evalMap(producer.send_)\n\n          consume.concurrently(produce)\n      }.compile.drain.as(ExitCode.Success)\n\n}\nAnother common Inject instance we use is an encoder / decoder based on the Circe library:\nimport io.circe._\nimport io.circe.parser.decode\nimport io.circe.syntax._\n\nimplicit def circeBytesInject[T: Encoder: Decoder]: Inject[T, Array[Byte]] =\n  new Inject[T, Array[Byte]] {\n    val inj: T => Array[Byte] =\n      t => t.asJson.noSpaces.getBytes(\"UTF-8\")\n\n    val prj: Array[Byte] => Option[T] =\n      bytes => decode[T](new String(bytes, \"UTF-8\")).toOption\n  }","title":"Quick start"}]}